# Database Adapters

`nestjs-durable-workflows` interacts with the database exclusively through the `IWorkflowDbAdapter` interface. This decouples the engine from any specific ORM or query builder.

## The `IWorkflowDbAdapter` Interface

```typescript
export interface IWorkflowDbAdapter {
  findOne(
    tableName: string,
    id: string,
    lock?: boolean,
  ): Promise<WorkflowRecord | null>;
  upsertLive(
    tableName: string,
    id: string,
    data: Omit<WorkflowRecord, 'id' | 'updatedAt'>,
  ): Promise<void>;
  insertHistory(
    tableName: string,
    data: Omit<HistoryRecord, 'id' | 'transitionedAt'>,
  ): Promise<void>;
  findExpired(tableName: string): Promise<{ id: string }[]>;
  findByState(tableName: string, stateValue: string): Promise<WorkflowRecord[]>;
  transaction<T>(cb: (adapter: IWorkflowDbAdapter) => Promise<T>): Promise<T>;
}
```

### Method Details

#### `findOne(tableName, id, lock?)`

Fetches a single workflow instance by ID. When `lock` is `true`, the query must use `SELECT ... FOR UPDATE` to acquire a row-level lock within the current transaction. Returns `null` if the instance doesn't exist.

#### `upsertLive(tableName, id, data)`

Inserts a new row or updates the existing row in the live table. Uses `INSERT ... ON CONFLICT (id) DO UPDATE` semantics. The `updatedAt` field should be set to the current timestamp by the database.

#### `insertHistory(tableName, data)`

Inserts a single row into the history table (`{tableName}_history`). The `id` and `transitionedAt` fields are generated by the database (UUID default and `CURRENT_TIMESTAMP`).

#### `findExpired(tableName)`

Returns the IDs of all instances where `expires_at < CURRENT_TIMESTAMP`. Used by the timeout cron service.

#### `findByState(tableName, stateValue)`

Returns all instances in a given state. Useful for consumer-driven cleanup, archival, or dashboards.

#### `transaction(cb)`

Executes the callback within a database transaction. The callback receives an adapter instance bound to that transaction. All `findOne`, `upsertLive`, and `insertHistory` calls inside the callback must execute within the same transaction.

## Using the Drizzle Adapter

The library ships with `DrizzleWorkflowAdapter` for [Drizzle ORM](https://orm.drizzle.team/).

```typescript
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';
import { DrizzleWorkflowAdapter } from 'nestjs-durable-workflows';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle(pool);

const adapter = new DrizzleWorkflowAdapter(db, 'orders');
```

### Constructor Parameters

| Parameter          | Type                        | Description                                                 |
| ------------------ | --------------------------- | ----------------------------------------------------------- |
| `db`               | `PgDatabase<any, any, any>` | A Drizzle database instance (from `drizzle()`)              |
| `defaultTableName` | `string`                    | A valid table name used for validation at construction time |

### Driver Compatibility

The adapter handles differences between PostgreSQL drivers automatically:

- **postgres-js**: `db.execute()` returns the result array directly
- **node-postgres** (`pg`): `db.execute()` returns `{ rows: [...] }`

An internal `extractRows()` helper normalizes both formats.

### SQL Injection Protection

Dynamic table names are validated against the pattern `/^[a-zA-Z_][a-zA-Z0-9_]*$/`. Any table name containing spaces, semicolons, quotes, or other special characters is rejected with an error at construction time and on every method call.

### Transaction Handling

When `transaction()` is called, the adapter creates a new `DrizzleWorkflowAdapter` instance bound to the Drizzle transaction context (`tx`). This ensures all operations inside the callback use the same transaction:

```typescript
await adapter.transaction(async (txAdapter) => {
  // txAdapter is a new DrizzleWorkflowAdapter backed by the transaction
  const record = await txAdapter.findOne('orders', id, true);   // FOR UPDATE
  await txAdapter.upsertLive('orders', id, { ... });             // same tx
  await txAdapter.insertHistory('orders', { ... });              // same tx
});
// COMMIT happens here
```

## Using the Prisma Adapter (Raw Queries)

The library also ships with `PrismaWorkflowAdapter` for [Prisma Client raw queries](https://www.prisma.io/docs/orm/prisma-client/using-raw-sql/raw-queries).

```typescript
import { PrismaClient } from '@prisma/client';
import { PrismaWorkflowAdapter } from 'nestjs-durable-workflows';

const prisma = new PrismaClient();
const adapter = new PrismaWorkflowAdapter(prisma, 'orders');
```

`PrismaWorkflowAdapter` depends only on raw-query method compatibility (`$queryRawUnsafe`, `$executeRawUnsafe`, and optional `$transaction`). The library itself does not import `@prisma/client`, so you only need Prisma installed in applications that use this adapter.

### Why Raw Queries?

Workflow table names are dynamic (`tableName` and `${tableName}_history`). Prisma model delegates (`prisma.order.findUnique`) require static model names, so the adapter uses raw SQL methods (`$queryRawUnsafe` / `$executeRawUnsafe`) with strict table-name validation.

### SQL Injection Protection

Prisma does not allow binding table names as query parameters. The adapter validates table names with `/^[a-zA-Z_][a-zA-Z0-9_]*$/` and only then inserts them as raw SQL fragments. All user data values (`id`, state values, JSON payloads, timestamps) remain parameterized.

### Transaction Handling

The adapter uses Prisma interactive transactions:

```typescript
await adapter.transaction(async (txAdapter) => {
  const record = await txAdapter.findOne('orders', id, true); // FOR UPDATE
  await txAdapter.upsertLive('orders', id, { ... });          // same tx
  await txAdapter.insertHistory('orders', { ... });           // same tx
});
```

## Using the node-postgres (`pg`) Adapter

The library also ships with `PgWorkflowAdapter` for [node-postgres (`pg`)](https://node-postgres.com/).

```typescript
import { Pool } from 'pg';
import { PgWorkflowAdapter } from 'nestjs-durable-workflows';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const adapter = new PgWorkflowAdapter(pool, 'orders');
```

The adapter supports:

- `SELECT ... FOR UPDATE` row locking in `findOne(..., lock=true)`
- `INSERT ... ON CONFLICT` upserts for live state
- transaction-scoped adapter instances via `BEGIN/COMMIT/ROLLBACK`

## Building a Custom Adapter

Implement `IWorkflowDbAdapter` for your preferred database library.

### Example: Raw `pg` Adapter

```typescript
import { Pool, PoolClient } from 'pg';
import {
  IWorkflowDbAdapter,
  WorkflowRecord,
  HistoryRecord,
} from 'nestjs-durable-workflows';

export class PgNativeAdapter implements IWorkflowDbAdapter {
  constructor(
    private readonly pool: Pool,
    private readonly client?: PoolClient,
  ) {}

  async findOne(
    tableName: string,
    id: string,
    lock?: boolean,
  ): Promise<WorkflowRecord | null> {
    const conn = this.client ?? this.pool;
    const lockClause = lock ? 'FOR UPDATE' : '';
    const result = await conn.query(
      `SELECT id, state_value, snapshot, expires_at, updated_at
       FROM ${tableName} WHERE id = $1 ${lockClause}`,
      [id],
    );

    if (result.rows.length === 0) return null;
    const row = result.rows[0];
    return {
      id: row.id,
      stateValue: row.state_value,
      snapshot: row.snapshot,
      expiresAt: row.expires_at ? new Date(row.expires_at) : null,
      updatedAt: new Date(row.updated_at),
    };
  }

  async upsertLive(
    tableName: string,
    id: string,
    data: Omit<WorkflowRecord, 'id' | 'updatedAt'>,
  ): Promise<void> {
    const conn = this.client ?? this.pool;
    await conn.query(
      `INSERT INTO ${tableName} (id, state_value, snapshot, expires_at, updated_at)
       VALUES ($1, $2, $3::jsonb, $4, CURRENT_TIMESTAMP)
       ON CONFLICT (id) DO UPDATE SET
         state_value = $2, snapshot = $3::jsonb,
         expires_at = $4, updated_at = CURRENT_TIMESTAMP`,
      [id, data.stateValue, JSON.stringify(data.snapshot), data.expiresAt],
    );
  }

  async insertHistory(
    tableName: string,
    data: Omit<HistoryRecord, 'id' | 'transitionedAt'>,
  ): Promise<void> {
    const conn = this.client ?? this.pool;
    await conn.query(
      `INSERT INTO ${tableName}_history
       (workflow_id, from_state, to_state, event_type, event_payload)
       VALUES ($1, $2, $3, $4, $5::jsonb)`,
      [
        data.workflowId,
        data.fromState,
        data.toState,
        data.eventType,
        JSON.stringify(data.eventPayload),
      ],
    );
  }

  async findExpired(tableName: string): Promise<{ id: string }[]> {
    const conn = this.client ?? this.pool;
    const result = await conn.query(
      `SELECT id FROM ${tableName} WHERE expires_at < CURRENT_TIMESTAMP`,
    );
    return result.rows.map((row: any) => ({ id: row.id }));
  }

  async findByState(
    tableName: string,
    stateValue: string,
  ): Promise<WorkflowRecord[]> {
    const conn = this.client ?? this.pool;
    const result = await conn.query(
      `SELECT id, state_value, snapshot, expires_at, updated_at
       FROM ${tableName} WHERE state_value = $1`,
      [stateValue],
    );
    return result.rows.map((row: any) => ({
      id: row.id,
      stateValue: row.state_value,
      snapshot: row.snapshot,
      expiresAt: row.expires_at ? new Date(row.expires_at) : null,
      updatedAt: new Date(row.updated_at),
    }));
  }

  async transaction<T>(
    cb: (adapter: IWorkflowDbAdapter) => Promise<T>,
  ): Promise<T> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      const txAdapter = new PgNativeAdapter(this.pool, client);
      const result = await cb(txAdapter);
      await client.query('COMMIT');
      return result;
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }
}
```

> **Important:** Validate table names in your adapter to prevent SQL injection. Use parameterized queries for all user-supplied values. Only use string interpolation for validated table/column names.

### Using Your Custom Adapter

```typescript
WorkflowModule.forRoot({
  adapter: new PgNativeAdapter(pool),
});
```
